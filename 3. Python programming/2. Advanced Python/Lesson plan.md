- [WATCH] Python imports
    - 3rd party imports
        - we often want to leverage the work of others and use their code
        - [SHOW] PYPI
            - people can publish python libraries to [PyPi](https://pypi.org) (the python package index)
        - and this is where our package manager, conda or pip, installs them from
        - this is how we make an import of a package we've installed
            - [DEMO] using conda: conda install pandas
            - [DEMO] using pip: pip install pandas
        - all that does is literally download the code from the internet, and put it in a place which is on our Python PATH, that is, a place on our computer where python looks for libraries when you import them
        - so how can you import files in python
    - local imports
        - sys is a library for accessing functions and parameters specific to your system
        - we can also import our own code from other places on our machine
        - [DEMO] import neighbouring file as module
            - `import neighbour`
            - that import is an object, and the variables defined inside are it's attributes
            - we can access them using the dot operator as usual
        - we can also use the `from` to import something from within a module 
        - the code we want might be a few folders deep, so we can use the . syntax to separate subfolders in our import statement
        - the thing at the end of your import statement must be a module or a variable, function or class
        - we can rename a module using `as`
            - `import numpy as np`
        - in python, importing a module runs the whole file
    - if name == main
        - we might have a file that when we run it explicitly, it computes some things
        - but it might also contain some stuff which we want to import into other code
        - we want a way to say, only run this block of code if the user run this file directly
        - useful for when we want to import that code without 
- [CHALLENGE] (10 mins) 
    - part 1: 3rd party libraries
        - install pandas using conda 
        - import pandas into your python script
        - give pandas an alias "pd" upon importing
        - from pandas, import the `DataFrame` class
    - part 2: local imports
        - create a folder called import_challenge and open it in vscode
        - in the folder create 2 files called 'main.py' and 'utils.py'
        - in the utils file, create a function called 'greeting' which prints a nice greeting
        - in the utils file, call this function
        - in the main file, import the greeting function from utils and run it
        - notice how the function gets run twice? once when the file is imported, and once when we called it directly. To stop this, let's put the direct call in an if name equals main block (feel free to look it up if you forget the syntax)
        - in this folder, create 2 folders called 'people' and 'sports'
        - in the people folder, create a file with a variable in, that is a list of the names of your group members
        - import this list into the main file and print it
        - inside the sports folder, create another 2 folders, called "skiing" and "climbing"
        - in each of these, define a simple class which has an initialiser that prints the name of the sport and a method called `equipment` which prints a the name of the sport and a piece of equipment you need to do it
        - try to import a module that does not exist, and handle this error with a try/except block

create your own nested file structure and python files with functions, variables and classes in and make sure you're comfortable with the imports
- [WATCH] [Comprehensions]()
    - list comprehensions
        - list comprehensions are more compact ways to implement for that generate values
        - `list = []`
        - `for i in range(3):`
            - `list.append(i**2)`
        - compressed: `[i**2 for i in range(3)]`
        - a simple way to "map" an iterable into another iterable
    - conditionals within comprehensions
        - `big_numbers = [num for num in range(10) if num > 10]
        - we can also use else statements in comprehensions
            - `numbers = [num if num < 5 else 'some wild big number' for num in range(10)]`
    - dictionary comprehensions
        - `names = ['harry', 'christina']`
        - `name_lengths = {name: len(name) for name in names}`
        - `print(name_lengths)`
        - again we can also use conditionals in dict comprehensions
- [CHALLENGE] 
    - for each challenge switch person
    - use a list comprehension to capitalise every element in the list `['Hello', 'world']`
    - use a list comprehension to filter out every multiple of 5 from a range of numbers up to 100
    - use a dictionary comprehension to create a map between every integer up to 15 and it's value squared
        - now, use a dictionary comprehension to create a dictionary that does the inverse! (hint: iterate over squares.items(), where squares is the name of the dict you made in the above challenge)
    - create a list of dictionaries, each with a key called name, then use a list comprehension to map that list to the names themselves by indexing the dicts
    - use the os module to create a nested list comprehension to list every file in the my_lib directory
- [BREAK]
- [WATCH] [Generators]()
    - generators are like lists except they generate the items on the fly
    - this means that you dont need to store every item of the list in memory
    - they can be converted to a list using the python builtin `list()`
    - we can create generators by writing a function and replacing the return statment with a yield statement
        - create infinite_iterable generator
    - when generators hit a yield statement, they dont exit like a regular function, instead they stop, remembering their current position
    - generators look much like functions, except instead of the return keyword, you'll find a `yield`
    - when we call a generator however, it does not return us what we find after the yield
        - instead, it returns us an iterable
    - generator comprehensions
- [CHALLENGE] (10 mins) 
    - iterate through each of the following generators to test them
    - create generator and iterate through it to infinitely cycle through a list of items in order
        - cast it to a list to print it
    - create a generator that generates random numbers
    - create a generator that takes in two numbers and generates all multiples of 3 between the two of them
    - create a generator that generates the square of every number up to 100, if that number is even or is a multiple of 3
    - turn the above generator into a generator comprehension
    - create a generator that generates generators which each generate ranges up to a random number passed to them as an argument :o
        - create a double nested for loop
        - the outer loop should iterate through the outer generator
        - the inner loop should iterate through the range generated by the inner generator
- [WATCH] Decorators
    - let's say i wanted to be alerted every time a function stopped and started
    - a naive solution would be to manually put print statements before and after
    - a better solution would be to write a function what returns another function
        - `wrapped_function = get_wrapped_function(my_function)`
        - `wrapped_function()`
    - by doing this, we've "decorated" the function with some added functionality before and after it's called
    - we're going to turn our `get_wrapped_function` function, into what is known as a decorator, which provides a better syntax for decorating functions
    - using a decorator looks like this: we put @decorator_name on the line directly above a function definition
    - this wraps that function with some extra functionality
    - define a decorator - a function which takes in a function, and returns a wrapped function, commonly called wrapper
    - `def print_before_and_after(func):`
        - `def wrapper():`
- [DEMO] static and class methods
    - static methods
        - are methods of a class that can be called directly as an attribute of the class object, not from an instantiated instance of the class
        - we can overwrite self being passed in by using the @staticmethod decorator
    - class methods
        - are like static methods, but are passed in a reference to the class itself, much like self is passed into an instance method
        - we can overwrite self being passed in, and pass in a reference to the class by using the @classmethod decorator


- [CHALLENGE]
    - to start with, create a simple function which we will decorate that loops over the numbers 1 to 3 and prints them
    - create a decorator that prints "start" and "end" at the start and end of a function call
    - create a decorator to time how long a function takes to run and print the duration
    - change your function so that it takes in an argument, which is the upper bound of the range which it iterates to
    - create a decorator that takes in a word as an argument, and prints this word before running
    - now make it take in a second argument word, which it prints after running the decorated function
- [WATCH] Context managers
    - Context managers allow you to allocate and release resources precisely when you want to, most commonly using the `with` statement
    - show example of open and close manually
        - `f = open('myfile')`
        - `f.close()`
    - show use of context manager
- [WATCH] [Typing in Python]()
    - python is not a strongly typed language, meaning we dont have to specify variable types
    - but we can specify them if we want
    - following a definition, put a colon and a type
        - x: int = 10
    - note that this will not throw an error if its not adhered to, it's currently just for helping make code more useable
    - so if you see something like this you'll know what it means
    - you can also type function arguments and outputs
        - `def my_function(name: str, age: int, height: float) -> bool:`
- [CHALLENGE] 
    - create a function which takes in a list of words and returns the total number of characters in the list, then type the function's inputs and outputs
    - 
turn your code to capitalise every element in a list into a function, then type that function
- [CHALLENGE] convert your



- lambda functions